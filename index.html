<!DOCTYPE html>
<style>
    html, body {
        margin: 0px;
        height: 100%;
    }
</style>
<html>
  
    <body>
        <!-- <input type="file" id="inputFile" onchan> -->
        <div style="display: grid; place-items: center; max-height: 100%; min-height: 100%;">
            <canvas id="viewer" width="1280" height="720"></canvas>
        </div>
        <!-- <a id="download" hidden>Download</a> -->
        
        <script src="./viewer.js"></script>
        <script>
            const params = new URLSearchParams(window.location.search);
            const file = params.get("image") || 'Frontdoor';
            Module.onRuntimeInitialized = async () => {
                const {
                    startupView,
                    allHotspots
                } = await (await fetch(`hotspots/${file}.json`)).json();
                
                const viewer = document.getElementById('viewer');
                const ctxViewer = viewer.getContext("2d");
                const image = document.createElement('img');
                

                image.onload = loadView;

                image.src = `./images/${file}.jpg`;

                function loadView() {

                {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext("2d");


                    canvas.width = image.naturalWidth;
                    canvas.height = image.naturalHeight;
                    ctx.drawImage(image, 0, 0);
                    const image_data = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    const nCubeSide = canvas.width / 2;

                    const srcPtr = Module._malloc(4 * canvas.width * canvas.height);
                    const dstPtr = Module._malloc(4 * nCubeSide * 6 * nCubeSide);

                    Module.HEAPU8.set(image_data.data, srcPtr);

                    Module._jsCubeMap(srcPtr, dstPtr, canvas.width, canvas.height);

                    // canvas.width = nCubeSide;
                    // canvas.height = 6 * nCubeSide;

                    // const dstImg = new Uint8ClampedArray(Module.HEAPU8.subarray(dstPtr, dstPtr + 4 * canvas.width * canvas.height));
                    // const dstImageData = new ImageData(dstImg, canvas.width);

                    // ctx.putImageData(dstImageData, 0, 0);

                    Module._free(srcPtr);
                    Module._free(dstPtr);
                    
                    // canvas.toBlob((blob) => {
                    //     document.getElementById("download").download = "Result.jpg";
                    //     document.getElementById("download").href = URL.createObjectURL(blob);
                    //     document.getElementById("download").click();
                    // }, "image/jpeg", 1);
                }



                let { theta0, phi0 } = startupView;
                let hfov = Math.PI * 100 / 180;

                const viewerData = Module._malloc(4 * viewer.width * viewer.height);
                const dstImageData = ctxViewer.getImageData(0, 0, viewer.width, viewer.height);
                let hotspots = [];


                function createHotspot(x, y, radius, action, popupText) {
                    const path = new Path2D();
                    path.arc(x, y, radius, 0, 2 * Math.PI);

                    return { x, y, path, action, popupText };
                }

                const renderFrame = () => {

                    Module._viewerQuery(viewerData, viewer.width, viewer.height, theta0, phi0, hfov);


                    dstImageData.data.set(Module.HEAPU8.subarray(viewerData, viewerData + 4 * viewer.width * viewer.height));
                    ctxViewer.putImageData(dstImageData, 0, 0);

                    hotspots = [];
                                    
                    const aspectRatio = viewer.height / viewer.width;
                    const f           = Math.tan(hfov / 2);
                    const vfov        = 2 * Math.atan(aspectRatio * f);

                    for (const { theta, phi, text, redirect } of allHotspots) {
                     
                        let x = Math.cos(theta - theta0) * Math.sin(phi);
                        let y = Math.sin(theta - theta0) * Math.sin(phi);
                        let z = Math.cos(phi);

                        const Rotx = x * Math.cos(phi0) - z * Math.sin(phi0);
                        const Roty = y;
                        const Rotz = x * Math.sin(phi0) + z * Math.cos(phi0);

                        if (Rotz <= 0) continue;

                        const t = 1 / Rotz;
                        x = Rotx * t / (f * aspectRatio);
                        y = Roty * t / f;

                        const row = Math.floor(viewer.height * (x + 1) / 2);
                        const col = Math.floor(viewer.width * (y + 1) / 2);
                        if (row < viewer.height && row >= 0 && 
                            col < viewer.width && col >= 0) {
                            hotspots.push(createHotspot(col, row, 25, () => {
                                if (redirect) window.location = `?image=${redirect}`;
                            }, text));
                        }

                    }
                    for (const hotspot of hotspots) {
                        ctxViewer.fillStyle = 'red';
                        ctxViewer.fill(hotspot.path);
                    }
                };

                renderFrame();


                        
                let isClicking = false;
                let prevPosition = null;

                const btnDownHandler = ({offsetX: x, offsetY: y}) => {

                    for (const hotspot of hotspots) {
                        if (ctxViewer.isPointInPath(hotspot.path, x, y)) {
                            hotspot.action();
                        }
                    }
                    isClicking = true;
                    prevPosition = {x, y};
                };

                const btnUpHandler = () => {
                    isClicking = false;
                    prevPosition = null;
                }

                let shownPopup = false;

                const btnMoveHandler = ({offsetX: x, offsetY: y}) => {
                    
                    if (!isClicking) {
                        renderFrame();
                        for (const hotspot of hotspots) {
                            if (ctxViewer.isPointInPath(hotspot.path, x, y)) {
                                
                                ctxViewer.font = "20px Verdana";
                                
                                ctxViewer.fillStyle = 'black';
                                ctxViewer.fillRect(hotspot.x - 75, hotspot.y - 60, 150, 25)
                                
                                ctxViewer.fillStyle = 'white';
                                ctxViewer.textAlign = "center";
                                ctxViewer.fillText(hotspot.popupText, hotspot.x, hotspot.y - 40, 150);
                            }
                        }
                    }
                    else {
                        const dx = x - prevPosition.x;
                        const dy = y - prevPosition.y;
                        theta0 += dx * 0.01;
                        phi0 += dy * 0.01;
                        if (phi0 < 0) phi0 = 0;
                        if (phi0 >= Math.PI) phi0 = Math.PI;
                        theta0 -= 2 * Math.PI * Math.floor(theta0 / (2 * Math.PI));
                        renderFrame();
                        prevPosition = {x, y};
                    }

                }

                viewer.onmousedown = btnDownHandler;
                viewer.onmousemove = btnMoveHandler;
                viewer.onmouseup = btnUpHandler;
                viewer.onmouseout = btnUpHandler;
                viewer.onwheel = ev => {
                    ev.preventDefault();
                    if (ev.deltaY > 0 && hfov < Math.PI * 150 / 180) hfov += 0.1;
                    if (ev.deltaY < 0 && hfov > 0.1) hfov -= 0.1;
                    
                    renderFrame();
                }



                viewer.ontouchstart = ev => {
                    ev.preventDefault();
                    const bbox = viewer.getBoundingClientRect();
                    btnDownHandler({
                        offsetX: ev.touches[0].clientX - bbox.x,
                        offsetY: ev.touches[0].clientY - bbox.y
                    });
                }
                viewer.ontouchmove = ev => {
                    ev.preventDefault();
                    const bbox = viewer.getBoundingClientRect();
                    btnMoveHandler({
                        offsetX: ev.touches[0].clientX - bbox.x,
                        offsetY: ev.touches[0].clientY - bbox.y
                    });
                };
                viewer.ontouchend = btnUpHandler;
                viewer.ontouchcancel = btnUpHandler;
            }




                


                // function selectedFile(ev) {

                //     const objectURL = URL.createObjectURL(ev.files[0]);
                //     const image = document.createElement('img');
                //     image.onload = () => loadView(objectURL);
                //     image.src = objectURL;
                // }
                // const inputField = document.getElementById("inputFile");

                // inputField.onchange = () => {
                //     inputField.setAttribute('hidden', '');
                //     selectedFile(inputField)
                // };


            }

            
        </script>
    </body>
</html>